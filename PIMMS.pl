#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use Statistics::Descriptive;

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

my $VERSION = "PIMMS pipeline version 1.91 Dec 2014";

my $usage = "===========================================================================================================
Pragmatic Insertional Mutation Mapping system (PIMMS) mapping pipeline\n===========================================================================================================
       o         o
       o         o
      //        //
     //        //
   |_||_|    |_||_|   @@@@@  @@@@@@  @@     @@  @@     @@   @@@@@@
   |@||@|    |@||@|   @@  @@   @@    @@@@ @@@@  @@@@ @@@@  @@
   |@||@|    |@||@|   @@@@@    @@    @@ @@@ @@  @@ @@@ @@   @@@
   |@||@|    |@||@|   @@       @@    @@  @  @@  @@  @  @@     @@@
   |@@@@|    |@@@@|   @@       @@    @@     @@  @@     @@       @@
   |@@@@|    |@@@@|   @@     @@@@@@  @@     @@  @@     @@  @@@@@@@
===========================================================================================================   
PIMMS.pl [-m module] [module options]


-m	module (one of mapping, process.sam, counts, compare)
-v	print version
-h	print help
type PIMMS.pl -m [module] without options for module specific help and usage.\n";


my ($version, $help, $module);
my ($command, $input1, $input2, $encoding, $run_id, $genome, $minimum_length, $maximum_length, $name, $quality_switch);
my ($sam,$collapse_bp, $mismatch, $ascore);
my ($depth_file, $gtf,$minimum_coverage);
my ($input, $output, $distance_to_collapse);

GetOptions(
	'm|module:s'     => \$module,
	'v|version:s'     => \$version,	
	'h|help:s'     => \$help,

	'c|command:s'	=> \$command,
	'i|input1:s'     => \$input1,
        'j|input2:s'     => \$input2,
	'e|encoding:s'     => \$encoding,
	'r|runid:s'     => \$run_id,
	'g|genome:s'     => \$genome,
	'min|minimum:s'     => \$minimum_length,
	'max|maximum:s'     => \$maximum_length,
	'n|name:s'     => \$name,	
	'q|quality:s' => \$quality_switch,

        's|sam:s'     => \$sam,
	'col|collapse:s'     => \$collapse_bp,
	'mis|mismatch:s'     => \$mismatch,
	'a|ascore:s'     => \$ascore,	
        
	'd|depth:s'     => \$depth_file,
	'gtf|gtf:s'     => \$gtf,
	'cov|coverage:s'     => \$minimum_coverage,

        'in|input:s'     => \$input, 
	'out|output:s'     => \$output,
	'dist|distance:s'     => \$distance_to_collapse,
	
);

if(defined $version) {
print "$VERSION\n"; exit;
}
if(defined $help) {
print "$usage\n"; exit;
}
elsif(! defined $module) {print "$usage\n"; exit;}

$module = lc $module;

unless ($module eq "mapping" | $module eq "process.sam" | $module eq "counts" | $module eq "compare")
{
print "\n$usage\nError: module -m $module not recognised!\n\n";exit;
}

####################################################################################################
#
# PIMMS MAPPING MODULE START
#
####################################################################################################
if ($module eq "mapping")
{
my $mapping_usage = "===========================================================================================================
PIMMS.pl mapping
=========================================================================================================== 
1) Read files are matched to user motifs and trimmed to retain potential insertion sequence
2) Resulting files are mapped to given reference genome
3) Basic statistics of mapped read positions are produced
Read files can be zipped (assumed ends in .gz)
Assumes Paired end reads fastq files 1 & 2 or Single end reads fastq file1
Assumes aligner used is in your path and options are defined in full in the PIMMS.commands.txt file.

Currently PIMMS supports bowtie2 and BWA if using these an appropriate index will be generated by PIMMS. 

If no aligner is provided the default recommended mapper BWA with options mem -t 4 will be be used.
If \"BWA\" is named without options the default options (mem -t 2) will be used.
If \"bowtie2\" is named without options the default options (-p 2 --end-to-end --very-sensitive) will be used.
additional or alternate options for BWA or bowtie2 can be specified in the PIMMS.command.txt file
===========================================================================================================
USAGE:
-c	PIMMS.command.txt user to edit to contain pair of motifs and optional aligner options
-i	Fastq file 1
-j	Fastq file 2 if single end reads write \"-j FALSE\"
-g	Path to reference genome for mapping
-e	Illumina encoding type [sanger, solexa or illumina]
-r 	Run id to be matched in fastq file e.g. \@M01661 including the \"@\"
-min	Minimum length of sequence post trimming to ensure is retained
-max	Maximum length of sequence post trimming that is returned
-n	Short name for identification of files (no spaces in name)
-q	generate fastq QC plots (can be slow with large fastq files) Y/N
===========================================================================================================
";

if( ! defined $command) {
print "$mapping_usage\nWARNING: Cannot proceed without PIMMS.command.txt\n\n"; exit;
}
elsif( ! defined $input1) {
print "$mapping_usage\nWARNING: Cannot proceed without input file fastq file 1\n\n"; exit;
}
elsif( ! defined $input2) {
print "$mapping_usage\nWARNING: Cannot proceed without input file fastq file 2\n\n"; exit;
}
elsif( ! defined $encoding) {
print "$mapping_usage\nWARNING: Cannot proceed without sequence encoding type\n\n"; exit;
}
elsif( ! defined $run_id) {
print "$mapping_usage\nWARNING: Cannot proceed without run id\n\n"; exit;
}
elsif( ! defined $genome) {
print "$mapping_usage\nWARNING: Cannot proceed without reference genome\n\n"; exit;
}
elsif( ! defined $minimum_length) {
print "$mapping_usage\nWARNING: Cannot proceed without minimum length of sequence post trimming to ensure is retained\n\n"; exit;
}
elsif( ! defined $maximum_length) {
print "$mapping_usage\nWARNING: Cannot proceed without maximum length of sequence post trimming that is returned\n\n"; exit;
}
elsif( ! defined $name) {
print "$mapping_usage\nWARNING: Cannot proceed without short name for identification of files\n\n"; exit;
}
elsif( ! defined $quality_switch) {
print "$mapping_usage\nWARNING: Cannot proceed without conduct quality control plotting Y/N?\n\n"; exit;
}


$quality_switch = lc $quality_switch;
unless ($quality_switch eq "y" || $quality_switch eq "n"){print "$mapping_usage\nWARNING: Cannot proceed without conduct quality control plotting Y/N?\n\n"; exit;}


#############################################################################################################################
# READ MOTIFS to be searched for in sequence and ALIGNER
open COMMANDS, $command;
my @commands = <COMMANDS>;
my $motif_1 = $commands[0]; 
my $motif_2 = $commands[1];
chomp ($motif_1, $motif_2);
$motif_1 =~ s/ //g;
$motif_2 =~ s/ //g;

my $mapper = "bwa"; # sets defaults
my $mapper_full = "bwa"; # sets defaults
my $mapper_options = "mem -t 2"; # sets defaults


if (exists $commands[2])
	{
	chomp $commands[2];
	if ($commands[2] =~ /(.*?)\s(.*)/)
		{
		$mapper_full = $1;
		$mapper_options = $2;
		$mapper = $mapper_full;
		if ($mapper_full =~ /.*\/(.*)/) {$mapper = $1;}

		}
	else {
		$mapper_full = $commands[2];
		$mapper = $mapper_full;
		if ($mapper_full =~ /.*\/(.*)/) {$mapper = $1;}
		if ($mapper eq "bowtie2")
			{
			$mapper_options = "-p 2 --end-to-end --very-sensitive"; # sets defaults for bowtie2
			}
		}
	}




my $now_string = localtime;
print "\n======================================================\nStarting PIMMS.mapping.pl $now_string\n======================================================\n";
print "Motif1 to be searched for = \"$motif_1\"\n";
print "Motif2 to be searched for = \"$motif_2\"\n";

$mapper = lc $mapper;


unless ($mapper eq"bwa" | $mapper eq "bowtie2")
	{
	print "Non standard alignment command = \"$mapper $mapper_options\"\nProceed? Yes/No\n";
	my $proceed = <>;
	chomp $proceed;
	
	$proceed = lc $proceed;
	if ($proceed ne "yes")
		{
		print "Error in mapper command. Check:$command\n"; exit;
		}
	}		

print "Alignment commands = \"$mapper $mapper_options\"\n======================================================\n";
#############################################################################################################################


#############################################################################################################################
#CREATE LOG
#############################################################################################################################
open LOG, ">$name\.PIMMS\.mapping.log";
$now_string = localtime;

print LOG "$mapping_usage\n";
my $commandline = $0;chomp $commandline;
print LOG "Command Used\n$commandline -m $module -c $command -i $input1 -j $input2 -e $encoding -r $run_id -g $genome -min $minimum_length -max $maximum_length -n $name\n\n";
print LOG "Motifs searched for\n$motif_1\n$motif_2\n";
print LOG "Alignment parameters\n$mapper $mapper_options\n";
print LOG "Time Started \= $now_string\n";

#############test.MODS.SHORT.PE.PIMMS.mapping.log################################################################################################################
#FILE PROCESSING
# zipped files are unzipped
#############################################################################################################################
print "Processing Files $now_string\n";
my @files_to_process = ();
my $directory1 = "./";
my $directory2 = "./";


my $file1 = $input1;
my $file2 = $input2;
my $name1 = $file1;
my $name2 = $file2;
chomp ($file1,$file2,$name1,$name2,$directory1,$directory2);

if ($input1 =~ /(.*\/)(.*)/){$directory1 = $1; $file1 = $2;}
if ($directory1 =~ /(.*?)\/$/){$directory1 = $1;}
if ($file1 =~ /((.*)\.gz$)/)
	{
	system "gunzip $input1";
	$name1 = $2;
	}
push @files_to_process, "$directory1\/$name1";

############ SKIP IF SINGLE END DATA INPUT ie -j = FALSE ################
if ($input2 ne "FALSE") {
	if ($input2 =~ /(.*\/)(.*)/){$directory2 = $1; $file2 = $2;}
	if ($directory2 =~ /(.*?)\/$/){$directory2 = $1;}
	if ($file2 =~ /((.*)\.gz$)/)
		{
		system "gunzip $input2";
		$name2 = $2;
		}
	push @files_to_process, "$directory2\/$name2";
	}
#############################################################


#############################################################################################################################
# RAW QUALITY PLOTS
# fastxtoolkit is used to generate quality plots of raw input fastq file. 
#############################################################################################################################

if ($quality_switch eq "y")
	{
	my $fastx_command1 = "fastx_quality_stats -i $input1 -o $name1.QC.stats";
	my $fastx_command3 = "fastq_quality_boxplot_graph.sh -i $input1.QC.stats -t $input1 -o $name1.Quality.png";
	if ($encoding eq "sanger")
		{
		$fastx_command1 = "fastx_quality_stats -Q33 -i $input1 -o $name1.QC.stats";
		}
	system "$fastx_command1";
	system "$fastx_command3";

	if ($input2 ne "FALSE") {
		my $fastx_command2 = "fastx_quality_stats -i $input2 -o $name2.QC.stats";
		my $fastx_command4 = "fastq_quality_boxplot_graph.sh -i $input2.QC.stats -t $input2 -o $name2.Quality.png";
		if ($encoding eq "sanger")
			{
			$fastx_command2 = "fastx_quality_stats -Q33 -i $input2 -o $name2.QC.stats";	
			}
		system "$fastx_command2";
		system "$fastx_command4";
		}

	print  LOG "\n=========================================================================\nQuality control plots of input data see directory PIMMS.QC.plots\nQuailty of reads per base position\n$input1.Quality.png\n";
	if ($input2 ne "FALSE")
		{
		print  LOG "$input2.Quality.png\n";
		}
	}

#############################################################################################################################
# MATCH ISS insertion
# for each input fastq file. Reads are searched for forward and reverse compliments of the search motifs. Those fulfilling the
# minimum criteria are trimmed to teh maximum length and written to file $short\.matched\.min$minimum_length\.max$maximum_length\.fastq
# numbers matched etc are recorded in the log file.  
#############################################################################################################################
$now_string = localtime;		
print "Matching motifs in fastq files $now_string\n";


### CREATE REV COMPS
my $foo = reverse $motif_1;
$foo =~ tr/ACGTacgt/TGCAtgca/;
my $motif_1_rev_comp = $foo;

my $bar = reverse $motif_2;
$bar =~ tr/ACGTacgt/TGCAtgca/;
my $motif_2_rev_comp = $bar;


print LOG "=========================================================================\nMatch reads to given motifs\n";

print LOG "PIMMS\.matched\.min$minimum_length\.max$maximum_length\.fastq\.summary\n";


my @short_names =();

foreach (@files_to_process)
	{
	chomp $_;
	my $file_processing = $_;
	my $short = $file_processing;
	if ($short =~ /.*\/(.*)/){$short = $1};
	my $motif_1_hit_count = 0;
	my $motif_2_hit_count = 0;
	my $motif_1_and_2_hit_count = 0;
	push @short_names, $short;
	my $count = 0;
	my $hitcount = 0;

	my $hit_but_short_m1 = 0;
	my $hit_but_short_m2 = 0;
	my $hit_but_short_m1_m2 = 0;
	
	open FASTQ, "$file_processing";
	open OUT1, ">$short\.matched\.min$minimum_length\.max$maximum_length\.fastq";
	
	{
	local $/ = "$run_id"; 
	<FASTQ>;                                             # throw away the first line 'cos will only contain "run_id"

		while (<FASTQ>) 
		{       
		chomp $_;
		my ($fastq_id, $fastqseq, $qual_id, $fastq_qual) = split "\n";            # split the fastq input into Id and sequence
		
		if ($fastqseq =~ /.*($motif_1)(.*)($motif_2).*/ || $fastqseq =~ /.*($motif_2_rev_comp)(.*)($motif_1_rev_comp).*/)
				{
				my $left = $1;
				my $captured = $2;
				my $right = $3;
				my $captured_length = length $captured;
				my $left_length = length $left;
				
				if ($captured_length >= $minimum_length)
					{
					if ($captured_length > $maximum_length) {$captured_length = $maximum_length;}
					my $captured_print = substr($captured, 0, $captured_length); #$seq, start, length of substring)
					my $captured_qual_print = substr($fastq_qual, $left_length, $captured_length); #$seq, start, length of substring)
					print OUT1 "$run_id"."$fastq_id\n$captured_print\n$qual_id\n$captured_qual_print\n";
					$hitcount++;
					}
				else {$hit_but_short_m1_m2++;}
				$motif_1_and_2_hit_count++;
				}
			 
			
			elsif ($fastqseq =~ /(.*)($motif_1)(.*)/  || $fastqseq =~ /(.*)($motif_2_rev_comp)(.*)/)
			
				{
				my $flank_left = $1;
				my $primer = $2;
				my $captured = $3;
				my $captured_length = length $captured;
				my $padding_length = ((length $flank_left) + (length $primer));
					
					if ($captured_length >= $minimum_length)
						{
						if ($captured_length > $maximum_length) {$captured_length = $maximum_length;}	
						my $captured_print = substr($captured, 0, $captured_length); #$seq, start, length of substring)
						
						my $captured_qual_print = substr($fastq_qual, $padding_length, $captured_length); #$seq, start, length of substring)
						print OUT1 "$run_id"."$fastq_id\n$captured_print\n$qual_id\n$captured_qual_print\n";
						$hitcount++;
						}
				if ($fastqseq =~ /(.*)($motif_1)(.*)/){$motif_1_hit_count++; if ($captured_length < $minimum_length) {$hit_but_short_m1++;}}
				if ($fastqseq =~ /(.*)($motif_2_rev_comp)(.*)/){$motif_2_hit_count++; if ($captured_length < $minimum_length) {$hit_but_short_m2++;}}
				}
			
			
			
			elsif ($fastqseq =~ /(.*)($motif_2)(.*)/  || $fastqseq =~ /(.*)($motif_1_rev_comp)(.*)/) 		

				{
				my $captured = $1;
				my $primer = $2;
				my $flank_right = $3;
				my $captured_length = length $captured;
				my $length_to_capture = $maximum_length;
				
			
				if ($captured_length >= $minimum_length)
						{
						if ($captured_length < $maximum_length) {$length_to_capture = $captured_length;}
						
						my $capture_start = ($captured_length - $length_to_capture);
										
						
						my $captured_print = substr($captured, $capture_start, $length_to_capture); #$seq, start, length of substring)
						my $captured_qual_print = substr($fastq_qual, $capture_start, $length_to_capture); #$seq, start, length of substring)
						chomp $captured_print;
						chomp $captured_qual_print;
						
						##################################################################################
						my $captured_print_rev = reverse $captured_print;   # ensures that the first base of the matched fragment is the inserion position. 
						$captured_print_rev =~ tr/ACGTacgt/TGCAtgca/; # ensures that the first base of the matched fragment is the inserion position
						my $captured_qual_print_rev = reverse $captured_qual_print; # ensures that the first base of the matched fragment is the inserion position
						##################################################################################
						
						print OUT1 "$run_id"."$fastq_id\n$captured_print_rev\n$qual_id\n$captured_qual_print_rev\n";
						$hitcount++;
						}
				if ($fastqseq =~ /(.*)($motif_2)(.*)/){$motif_2_hit_count++; if ($captured_length < $minimum_length) {$hit_but_short_m2++;}}
				if ($fastqseq =~ /(.*)($motif_1_rev_comp)(.*)/){$motif_1_hit_count++; if ($captured_length < $minimum_length) {$hit_but_short_m1++;}}
				}
			
			$count++;
			}				
		}
	

	my $hit_pc = sprintf("%.2f", ($hitcount/$count)*100);
	print LOG "File\tTotal Reads\tSequences matched\tPercent matched (Seqeuences matched/Total Reads)\n";
	print LOG "$file_processing\t$count\t$hitcount\t$hit_pc\n";
	print LOG "=========================================================================\nMotif_matched_count\n";
	
	my $pc_motif_1 = sprintf ("%.2f", (($motif_1_hit_count-$hit_but_short_m1)/$hitcount)*100);
	my $pc_motif_2 = sprintf ("%.2f", (($motif_2_hit_count-$hit_but_short_m2)/$hitcount)*100);
	my $pc_motif_1_and_2 = sprintf ("%.2f", (($motif_1_and_2_hit_count-$hit_but_short_m1_m2)/$hitcount)*100);
	
	my $motif_1_hit_count_long = ($motif_1_hit_count-$hit_but_short_m1);
	my $motif_2_hit_count_long = ($motif_2_hit_count-$hit_but_short_m2);
	my $motif_1_and_2_hit_count_long = ($motif_1_and_2_hit_count-$hit_but_short_m1_m2);
	
	print LOG "Motif 1\($motif_1\) or reverse complement passing minimum length cutoff $motif_1_hit_count_long \($pc_motif_1\% of $hitcount\)\n";
	print LOG "Motif 2\($motif_2\) or reverse complement passing minimum length cutoff $motif_2_hit_count_long \($pc_motif_2\% of $hitcount\)\n";
	print LOG "Motif 1 AND Motif 2 passing minimum length cut off $motif_1_and_2_hit_count_long \($pc_motif_1_and_2\% of $hitcount\)\n";
	
	print LOG "Motif 1\($motif_1\) matched but < minimum length $hit_but_short_m1\n";
	print LOG "Motif 2\($motif_2\) matched but < minimum length $hit_but_short_m2\n";
	print LOG "Motif 1 AND MOtif 2\ matched but < minimum length $hit_but_short_m1_m2\n";	
	print LOG "=========================================================================\n";
	close OUT1;
}
close FASTQ;

#############################################################################################################################
# Count matched pairs
#To avoid the potential of double counting of a single insertion from paired end reads, if both pairs of a read match
# the insertion motif, only a single end is retained in the file (-n).PIMMS.processed.se.fastq 
#############################################################################################################################
$now_string = localtime;		

if ($input2 ne "FALSE")
	{
	print "Filtering and merging pairs $now_string\n";

	my $ISS_match_paired_count = 0;
	my $ISS_match_single_count = 0;

	my %lookup_hash1;
	open FASTQ1, "$short_names[0]\.matched\.min$minimum_length\.max$maximum_length\.fastq";
		{
			local $/ = "$run_id"; 
			<FASTQ1>;                                             # throw away the first line 'cos will only contain "run_id"

				while (<FASTQ1>) 
				{       
				chomp $_;
				my ($fastq_id, $fastqseq, $qual_id, $fastq_qual) = split "\n";            # split the fastq input into Id and sequence
				my $id_short = $fastq_id;
				if ($fastq_id =~ /(.*)\s/){$id_short = $1;}
				$lookup_hash1{$id_short} = "$run_id"."$fastq_id\n$fastqseq\n$qual_id\n$fastq_qual";
				}
		}
	close FASTQ1;


	my %lookup_hash2;
	open FASTQ2, "$short_names[1]\.matched\.min$minimum_length\.max$maximum_length\.fastq";
		{
			local $/ = "$run_id"; 
			<FASTQ2>;                                             # throw away the first line 'cos will only contain "run_id"

				while (<FASTQ2>) 
				{       
				chomp $_;
				my ($fastq_id, $fastqseq, $qual_id, $fastq_qual) = split "\n";            # split the fastq input into Id and sequence
				my $id_short = $fastq_id;
				if ($fastq_id =~ /(.*)\s/){$id_short = $1;}
				$lookup_hash2{$id_short} = "$run_id"."$fastq_id\n$fastqseq\n$qual_id\n$fastq_qual";
				}
		}
	close FASTQ2;

	open OUT2, ">$name\.PIMMS.processed.se.fastq";
	open FASTQ1, "$short_names[0]\.matched\.min$minimum_length\.max$maximum_length\.fastq";
		{
			local $/ = "$run_id"; 
			<FASTQ1>;                                             # throw away the first line 'cos will only contain "run_id"

				while (<FASTQ1>) 
				{       
				chomp $_;
				my ($fastq_id, $fastqseq, $qual_id, $fastq_qual) = split "\n";            # split the fastq input into Id and sequence
				my $id_short = $fastq_id;
				if ($fastq_id =~ /(.*)\s/){$id_short = $1;}
				
				
				if (exists ($lookup_hash2{$id_short}))
					{
					$ISS_match_paired_count++;
					print OUT2"$lookup_hash1{$id_short}\n"; 
					}
				else 
					{
					$ISS_match_single_count++;
					print OUT2"$lookup_hash1{$id_short}\n";
					}
				}
		}
	close FASTQ1;


	open FASTQ2, "$short_names[1]\.matched\.min$minimum_length\.max$maximum_length\.fastq";
	{
			local $/ = "$run_id"; 
			<FASTQ2>;                                             # throw away the first line 'cos will only contain "run_id"

				while (<FASTQ2>) 
				{       
				chomp $_;
				my ($fastq_id, $fastqseq, $qual_id, $fastq_qual) = split "\n";            # split the fastq input into Id and sequence
				my $id_short = $fastq_id;
				if ($fastq_id =~ /(.*)\s/){$id_short = $1;}
				
				if (exists ($lookup_hash1{$id_short})){}
				
				else{
					{
					$ISS_match_single_count++;
					print OUT2"$lookup_hash2{$id_short}\n";
					}
					}
				}
	}
	close FASTQ2;
	close OUT2;
	print LOG "Count matched pairs\nSingle End Reads\:$ISS_match_single_count\nPaired End Reads\:$ISS_match_paired_count\nCombined single end output File\:$name\.PIMMS.processed.se.fastq\n";
}


#############################################################################################################################
# QUALITY PLOTS OF PROCESSED READS
# fastxtoolkit is used to determine and draw plots of read quality of the processed [(-n).PIMMS.processed.se.fastq] fastq file.
#############################################################################################################################

if ($quality_switch eq "y")
	{
	if ($input2 ne "FALSE")
		{
		my $fastx_command5 = "fastx_quality_stats -i $name\.PIMMS.processed.se.fastq -o $name\.PIMMS.processed.se.fastq.QC.stats";
		my $fastx_command6 = "fastq_quality_boxplot_graph.sh -i $name\.PIMMS.processed.se.fastq.QC.stats -o $name\.PIMMS.processed.se.fastq.Quality.png";
		my $fastx_command7 = "fastx_nucleotide_distribution_graph.sh -i $name\.PIMMS.processed.se.fastq.QC.stats -o $name\.PIMMS.processed.se.fastq.Nucl.dist.png";

		if ($encoding eq "sanger") {$fastx_command5 = "fastx_quality_stats -Q33 -i $name\.PIMMS.processed.se.fastq -o $name\.PIMMS.processed.se.fastq.QC.stats";}

		system "$fastx_command5";
		system "$fastx_command6";
		system "$fastx_command7";

		print  LOG "=========================================================================\nQuality control plots of Processed Data see directory PIMMS.QC.plots\nQuailty of reads per base position\:PIMMS.processed.se.fastq.Quality.png\nNucleotide Distribution\:PIMMS.processed.se.fastq.Nucl.dist.png\n";
		}
}
#############################################################################################################################
# MAPPING WITH CHOSEN ALIGNER
#############################################################################################################################


if ($mapper eq "bwa")
	{
		if (-e "$genome\.amb"){}
		else {
		$now_string = localtime;		
		print "building bwa index $now_string\n";
		system "$mapper_full index $genome";
		}


	if ($input2 ne "FALSE")
		{
		$now_string = localtime;		
		print "Aligning reads using $mapper $now_string\n";
		print  LOG "=========================================================================\nmapper command\n$mapper $mapper_options $genome $name\.PIMMS.processed.se.fastq \> $name\.PIMMS.processed.se.fastq.mapped.sam\n"; 
		close LOG;
		system "$mapper $mapper_options $genome $name\.PIMMS.processed.se.fastq > $name\.PIMMS.processed.se.fastq.mapped.sam 2>>$name\.PIMMS\.mapping.log";
		open LOG, ">>$name\.PIMMS\.mapping.log";
		$now_string = localtime;		
		print  LOG "=========================================================================\nFinished $now_string\n";
		}
	else {
		$now_string = localtime;		
		print "Aligning reads using $mapper $now_string\n";
		print  LOG "=========================================================================\nmapper command\n$mapper $mapper_options $genome $short_names[0]\.matched\.min$minimum_length\.max$maximum_length\.fastq \> $name\.PIMMS.processed.se.fastq.mapped.sam\n"; 
		close LOG;
		system "$mapper $mapper_options $genome $short_names[0]\.matched\.min$minimum_length\.max$maximum_length\.fastq > name\.PIMMS.processed.se.fastq.mapped.sam 2>>$name\.PIMMS\.mapping.log";
		open LOG, ">>$name\.PIMMS\.mapping.log";
		$now_string = localtime;		
		print  LOG "=========================================================================\nFinished $now_string\n";
		}
	}



elsif ($mapper eq "bowtie2")
	{
		if (-e "$genome.\.1\.bt2"){}
		else {
		$now_string = localtime;		
		print "building bowtie2 index $now_string\n";
		system "$mapper_full\-build -q $genome $genome";
		}


	if ($input2 ne "FALSE")
		{
		$now_string = localtime;		
		print "Aligning reads using $mapper $now_string\n";
		print  LOG "=========================================================================\nmapper command\n$mapper $mapper_options -x $genome $name\.PIMMS.processed.se.fastq -S $name\.PIMMS.processed.se.fastq.mapped.sam\n"; 
		close LOG;
		system "$mapper $mapper_options -x $genome $name\.PIMMS.processed.se.fastq -S $name\.PIMMS.processed.se.fastq.mapped.sam 2>>$name\.PIMMS\.mapping.log";
		open LOG, ">>$name\.PIMMS\.mapping.log";

		$now_string = localtime;		
		print  LOG "=========================================================================\nFinished $now_string\n";
		}
	else {
		$now_string = localtime;		
		print "Aligning reads using $mapper $now_string\n";
		print  LOG "=========================================================================\nmapper command\n$mapper $mapper_options -x $genome $short_names[0]\.matched\.min$minimum_length\.max$maximum_length\.fastq -S $name\.PIMMS.processed.se.fastq.mapped.sam\n"; 
		close LOG;
		system "$mapper $mapper_options -x $genome $short_names[0]\.matched\.min$minimum_length\.max$maximum_length\.fastq -S name\.PIMMS.processed.se.fastq.mapped.sam 2>>$name\.PIMMS\.mapping.log";
		open LOG, ">>$name\.PIMMS\.mapping.log";
		$now_string = localtime;		
		print  LOG "=========================================================================\nFinished $now_string\n";
		}
	}

else {
		$now_string = localtime;		
		print "Aligning reads using $mapper $now_string\n";
		print  LOG "=========================================================================\nmapper command\n$mapper $mapper_options $genome $short_names[0]\.matched\.min$minimum_length\.max$maximum_length\.fastq > $name\.PIMMS.processed.se.fastq.mapped.sam\n"; 
		close LOG;
		system "$mapper $mapper_options $genome $short_names[0]\.matched\.min$minimum_length\.max$maximum_length\.fastq > $name\.PIMMS.processed.se.fastq.mapped.sam 2>>$name\.PIMMS\.mapping.log";
		open LOG, ">>$name\.PIMMS\.mapping.log";
		$now_string = localtime;		
		print  LOG "=========================================================================\nFinished $now_string\n";
		}
	
	




	
#############################################################################################################################
# CLEAN UP
#############################################################################################################################
if ($input2 ne "FALSE")
	{
	if (-e "PIMMS.processed.reads"){system "mv $name\.PIMMS.processed.se.fastq \*.matched\.min$minimum_length\.max$maximum_length\.fastq ./PIMMS.processed.reads\/";}
	else {system  "mkdir PIMMS.processed.reads"; system "mv $name\.PIMMS.processed.se.fastq \*.matched\.min$minimum_length\.max$maximum_length\.fastq PIMMS.processed.reads\/";}
	}
else {
	if (-e "PIMMS.processed.reads"){system "mv $short_names[0]\.matched\.min$minimum_length\.max$maximum_length\.fastq ./PIMMS.processed.reads\/";}
	else {system "mkdir PIMMS.processed.reads"; system "mv $short_names[0]\.matched\.min$minimum_length\.max$maximum_length\.fastq ./PIMMS.processed.reads\/";}
	}


if (-e "$genome\.1.bt2")
	{
	if (-e "Genome.index.files") {system "mv $genome*.bt2 Genome.index.files\/";}
	else {system "mkdir Genome.index.files"; system "mv $genome*.bt2 Genome.index.files\/";}
	}

if (-e "$genome\.amb")
	{
	if (-e "Genome.index.files") {system "mv $genome\.amb $genome\.ann $genome\.bwt $genome\.pac $genome\.sa Genome.index.files\/";}
	else {system "mkdir Genome.index.files"; system "mv $genome\.amb $genome\.ann $genome\.bwt $genome\.pac $genome\.sa Genome.index.files\/";}
	}


unless (-d "Mapped.reads.sam.file"){system "mkdir Mapped.reads.sam.file";}
system "mv *.mapped.sam Mapped.reads.sam.file\/";

if ($quality_switch eq "y")
	{
	if (-e "PIMMS.QC.plots"){system "mv *.png *.stats ./PIMMS.QC.plots\/";}
	else {system  "mkdir PIMMS.QC.plots"; system "mv *.png *.stats ./PIMMS.QC.plots\/";}
	}
}


####################################################################################################
#
# PIMMS PROCESS SAM FILE MODULE START
#
####################################################################################################
if ($module eq "process.sam")
{
my $process_usage = "===============================================================================================================
PIMMS pipeline turn sam file into read.depth.file for later analysis. 
=============================================================================================================== 
USAGE:
-s	Mapped reads in sam format
-n	Short name for identification of output files (no spaces in name, keep short)
-col	Collapse and add depth of insertion EXACTLY x bp apart. (OPTIONAL use -c N to turn off).
-mis	Maximum mismatch allowed in alignment (filters on \"MD\" tag of sam file)
	if m = 0 or m >= 1 then counts mismatches
	if fraction is given then counts proportion of read length ie 0.1 = 10% of read length can mismatch
-a	Minimum alignment quality (this needs to be relevant for aligner used). Reads with AS score less
	than this are discarded.
	If using bowtie2 aligner - to avoid problems with using negative numbers on the commandline if you
	wish to have a minimum < 0 type -a neg[integer] e.g. neg10 will be interpreted as -10. 
===============================================================================================================
" ;

if( ! defined $sam) {
print "$process_usage\nWARNING: Cannot proceed without sam file \n\n"; exit;
}
if( ! defined $name) {
print "$process_usage\nWARNING: Cannot proceed without short name for identification of files\n\n"; exit;
}
if( ! defined $collapse_bp) {
print "$process_usage\nWARNING: Cannot proceed without variable to collapse adjacent insertion sites\n\n"; exit;
}
if( ! defined $mismatch) {
print "$process_usage\nWARNING: Cannot proceed without maximum mismatch allowed\n\n"; exit;
}
if( ! defined $ascore) {
print "$process_usage\nWARNING: Cannot proceed without minimum alignment score\n\n"; exit;
}

my $mismatch_flag = "count";
if ($mismatch =~ /\d\.\d+/) {$mismatch_flag = "fraction";}
if ($ascore =~/neg(\d+)/) {$ascore = "-".$1;}


#############################################################################################################################
#CREATE LOG
#############################################################################################################################
open LOG, ">$name\.m$mismatch\.a$ascore\.PIMMS\.processing.collapse\.$collapse_bp\.log";
my $time = localtime;

print LOG "$process_usage\n";
my $commandline = $0;
print LOG "Command Used\n$commandline -m $module -s $sam -n $name -c $collapse_bp -mis $mismatch -a $ascore\n\n";
print LOG "Time Started \= $time";



#############################################################################################################################
#PROCESS SAM FILE
# Insertion positions are determined from the map position of reads. The Sam flags are used to determine if the reads are
# mapped on the forward or reverse strand and the map positions are determined from these positions. The scripts retains a
# tally depth at each unique insertion position. 
#############################################################################################################################

$time= localtime;		
print "Starting processing sam file\t$time\n";
open SAM, "$sam";

my $total_mapped_read_count = 0;
my $total_read_count = 0;
my $genome = 


my %sam_hit_positions; # key position ==> depth


while (<SAM>)
{
chomp $_;
	if ($_ =~ /^@/){}
	else 
		{
		my $line = $_;
		my @data = split '\t', $line;
		my $sam_start = $data[3];
		my $sam_cigar = $data[5];
		my $sam_flag = $data[1];
		my $true_insertion_point = 0;
		my $MD_tag = "";
		my $AS_score = -1000;
		

		if ($sam_cigar =~ /(\d+)M/)
			{
			my $match_length = $1;
			
			if ($line =~ /.*(MD\:Z\:[A-Za-z0-9]*).*/){$MD_tag = $1;}
				if ($MD_tag =~ /MD\:Z\:(.*)/){$MD_tag = $1;}
				
				my $number_mismatch = () = $MD_tag =~ /[A-Z]/gi;

				if ($line =~ /.*AS\:i\:(\-*\d+).*/){$AS_score = $1;}				
				
				if ($mismatch_flag eq "count")
					{
					if ($number_mismatch <= $mismatch && $AS_score >= $ascore)
							{
							$true_insertion_point = $sam_start;
							if (exists $sam_hit_positions{$true_insertion_point})
								{
								my $position_count = ($sam_hit_positions{$true_insertion_point} + 1);
								$sam_hit_positions{$true_insertion_point} = $position_count;
								}
							else {$sam_hit_positions{$true_insertion_point} = 1;}
							$total_mapped_read_count++;
							}
					}
					
					
				elsif ($mismatch_flag eq "fraction")
					{
					if ($number_mismatch <= $mismatch*$match_length && $AS_score >= $ascore)
							{
							$true_insertion_point = $sam_start;
							if (exists $sam_hit_positions{$true_insertion_point})
								{
								my $position_count = ($sam_hit_positions{$true_insertion_point} + 1);
								$sam_hit_positions{$true_insertion_point} = $position_count;
								}
							else {$sam_hit_positions{$true_insertion_point} = 1;}
							$total_mapped_read_count++;
							}
					}
						
			
			$total_read_count++;
			}	
		}
}
close SAM;

my $total_mapped_positions = $total_mapped_read_count;
my $unique_mapped_positions = scalar scalar keys %sam_hit_positions;

my $mean_read_depth = 0;
unless ($unique_mapped_positions == 0) {$mean_read_depth = sprintf("%.2f", ($total_mapped_positions/$unique_mapped_positions));}

my $percent_mapped = sprintf("%.2f", (($total_mapped_read_count / $total_read_count)*100));
my $sam_short = $sam;
if ($sam =~ /.*?\/(.*)/){$sam_short = $1;}

my @all_unique_positions = ();


#############################################################################################################################
# OUTPUT READ DEPTHS
#############################################################################################################################
open OUT, ">$name\.m$mismatch\.a$ascore\.PIMMS\.processing.collapse\.$collapse_bp\.positions\.depths";
print OUT "Position\tDepth\n";

foreach my $key (sort { $a <=> $b } keys(%sam_hit_positions) )
        {
	push @all_unique_positions, $key;
	if ($collapse_bp eq "N" || $collapse_bp eq  "n")
		{
		print OUT "$key\t$sam_hit_positions{$key}\n";
		}
	}

my $collapsed_position_count = 0;
my $collapsed_position_reads = 0;
my $reads_collapsed_only = 0;

if ($collapse_bp =~ /\d+/)
	{
	$time= localtime;
	print "Collapsing reads $collapse_bp bp distance\t$time\n";
	my $linecount = 0;
	
	foreach (@all_unique_positions)
		{
		chomp $_;
		
		if (exists $all_unique_positions[$linecount])
			{
			my $current_position = $all_unique_positions[$linecount];
			
			my $current_position_count = $sam_hit_positions{$current_position};
			
			
			if (exists $all_unique_positions[$linecount+1])
				{
				my $possible_match = $all_unique_positions[$linecount+1];
				
				if ((($current_position + $collapse_bp) -1)== $possible_match)
					{
					my $collapse_count = ($sam_hit_positions{$current_position}+ $sam_hit_positions{$possible_match});
					print OUT "$current_position\t$collapse_count\n";
					$collapsed_position_count++;
					$collapsed_position_reads = ($collapsed_position_reads+$collapse_count);
					$linecount++; #skip the line you just added
					$reads_collapsed_only = ($reads_collapsed_only + $collapse_count)
					}
				else {
					print OUT "$current_position\t$sam_hit_positions{$current_position}\n";
					$collapsed_position_count++;
					$collapsed_position_reads = ($collapsed_position_reads+$sam_hit_positions{$current_position});
					}
				
				}
			else 
				{
				print OUT "$current_position\t$sam_hit_positions{$current_position}\n";
				$collapsed_position_count++;
				$collapsed_position_reads = ($collapsed_position_reads+$sam_hit_positions{$current_position});
				}
			$linecount++;
			}
		}
	}
	


print LOG "\n===============================================================================================================\n";
print LOG "Sam File processed\: $sam_short\n";
print LOG "Total Reads in $sam_short\: $total_read_count\n";
print LOG "Total Reads mapped to reference genome\: $total_mapped_positions\n";
print LOG "Percent of reads mapped to reference genome\: $percent_mapped\%\n";
print LOG "Unique mapped positions\: $unique_mapped_positions\n";
print LOG "Mean read depth per mapped postion\: $mean_read_depth\n";
print LOG "===============================================================================================================\n";
print LOG "Collapsed Reads at $collapse_bp \(N = collapse option off\)\n";
if ($collapse_bp =~ /\d+/)
{

print LOG "Total reads mapped after positions collapsing\: $collapsed_position_reads\n";
print LOG "Reads collapsed\: $reads_collapsed_only\n";
print LOG "Unique mapped positions after collapsing\: $collapsed_position_count\n";

my $mean_depth_after_collapsed = 0;
unless ($collapsed_position_count ==0) {$mean_depth_after_collapsed = sprintf("%.2f", ($collapsed_position_reads/$collapsed_position_count));}
print LOG "Mean depth at position after collapsing\: $mean_depth_after_collapsed\n";

my $percent_of_positions_collapsed = 0;
unless ($unique_mapped_positions ==0) {$percent_of_positions_collapsed = sprintf("%.2f", ((($unique_mapped_positions - $collapsed_position_count)/$unique_mapped_positions)*100));}

my $percent_of_reads_collapsed  = 0;
unless ($total_mapped_positions == 0){$percent_of_reads_collapsed = sprintf("%.2f", (($reads_collapsed_only/$total_mapped_positions)*100));}
print LOG "Percent of total positions collapsed\: $percent_of_positions_collapsed\%\n";
print LOG "Percent of total reads collapsed\: $percent_of_reads_collapsed\%\n";

}
print LOG "===============================================================================================================\n";

unless (-d "PIMMS.position.depth.files"){system "mkdir PIMMS.position.depth.files";}
system "mv $name\.m$mismatch\.a$ascore\.PIMMS\.processing.collapse\.$collapse_bp\.positions\.depths PIMMS.position.depth.files\/";
}


####################################################################################################
#
# PIMMS COUNTS MODULE START
#
####################################################################################################
if ($module eq "counts")
{
my $counts_usage = "===============================================================================================================
PIMMS counts module
=============================================================================================================== 
USAGE:
-d	Mapped reads position depth file (output of PIMMS.process.SAM.pl)
-g	Reference genome in fasta format
-gtf	Reference gtf file
-cov	Minimum coverage filter (minimum coverage at insertion site to report)
-n	Short name for identification of files (no spaces in name, use same as for PIMMS.process.SAM.pl) 
===============================================================================================================
" ;


if( ! defined $depth_file) {	
print "$counts_usage\nWARNING: Cannot proceed without mapped reads position depth file (output of PIMMS.process.SAM.pl) \n\n"; exit;
}
if( ! defined $gtf) {
print "$counts_usage\nWARNING: Cannot proceed without GTF file\n\n"; exit;
}
if( ! defined $genome) {
print "$counts_usage\nWARNING: Cannot proceed without reference genome\n\n"; exit;
}
if( ! defined $minimum_coverage) {
print "$counts_usage\nWARNING: Cannot proceed without minimum coverage at insertion site to report\n\n"; exit;
}
if( ! defined $name) {
print "$counts_usage\nWARNING: Cannot proceed without short name for identification of files\n\n"; exit;
}

#############################################################################################################################
#CREATE LOG
#############################################################################################################################
open LOG, ">$name\.PIMMS\.counts\.min_cov\.$minimum_coverage\.log";
my $time = localtime;

print LOG "$usage\n";
my $commandline = $0;
print LOG "Command Used\n$commandline -m $module -d $depth_file -gtf $gtf -g $genome -cov $minimum_coverage -n $name\n\n";
print LOG "Time Started \= $time";


#################################################################################################################
# PROCESS GTF FILE
# Path to reference GTF file. Within the annotation detail column (column 9 of GTF file). 
# Attempts to retain information for CDS using "locus_tag", "gene" and "product" flags. 
# Assumes standard GTF file format, column 1 = genome, column 3 = data source, column 4 = genome start position,
# column 5 = genome end position and column 7 = strand.

# Due to multiple genes called the same id e.g 16S rRNA need to use the positions as key. 
# Foreach position in the genome will generate a gene, locus, source etc look up
#################################################################################################################

$time = scalar localtime;
print "\nStarting parsing GTF file\t$time\n"; 

open GTF, "$gtf";


my %gene_lookup;
my %product_lookup;
my %length_lookup;
my %locus_lookup;
my %source_lookup;
my %start_lookup;
my %stop_lookup;
my %base_as_centile_of_coding;
my %universal_id; # if known will be locus id if not will be gene ID. 
my %univeral_id_keys; # if known will be locus id if not will be gene ID. 

my %universal_id_lookup_gene;  	#key is all universal ids for prodcution of final tables. 
my %universal_id_lookup_start; 	#key is all universal ids for prodcution of final tables.
my %universal_id_lookup_stop; 	#key is all universal ids for prodcution of final tables.
my %universal_id_lookup_length; 	#key is all universal ids for prodcution of final tables.
my %universal_id_lookup_product; 	#key is all universal ids for prodcution of final tables.
my %universal_id_lookup_strand; 	#key is all universal ids for prodcution of final tables.

while (<GTF>)
{
chomp $_;
my @data = split '\t', $_;
my $details = $data[8];

my $locus = "NA";
my $gene = "NA";
my $product = "NA";
my $base_position_as_percentile = "NA";
my $source = $data[2];
my $start = $data[3];
my $stop = $data[4];
my $strand = $data[6];
my $genome = $data[0]
;
my $length = 0;
my @range = ();

if ($details =~ /locus_tag\s\"(.*?)\"/) {$locus = $1};
if ($details =~ /gene\s\"(.*?)\"/) {$gene = $1};
if ($details =~ /product\s\"(.*?)\"/){$product = $1};

if ($source eq "CDS")
	{
	@range = ($start..$stop);
	$length = ($stop-$start)+1;
	$length_lookup{$locus} = $length;
	$start_lookup{$locus}= $start;
	$stop_lookup{$locus}= $stop;
	foreach (@range)
	{
	chomp $_;
	if ($locus ne "NA") 
		{
		$universal_id{$_} = $locus;
		$univeral_id_keys{$locus} = 1;
		$universal_id_lookup_gene{$locus} = $gene;
		$universal_id_lookup_start{$locus} = $start;
		$universal_id_lookup_stop{$locus} = $stop;
		$universal_id_lookup_length{$locus} = $length;
		$universal_id_lookup_product{$locus} = $product;
		$universal_id_lookup_strand{$locus} = $strand;
		}
	else {
		$universal_id{$_} = $gene;
		$univeral_id_keys{$gene} = 1;
		$universal_id_lookup_gene{$gene} = $gene;
		$universal_id_lookup_start{$gene} = $start;
		$universal_id_lookup_stop{$gene} = $stop;
		$universal_id_lookup_length{$gene} = $length;
		$universal_id_lookup_product{$gene} = $product;
		$universal_id_lookup_strand{$gene} = $strand;
		}
	
	$gene_lookup{$_} = $gene;
	$product_lookup{$_} = $product;
	$locus_lookup{$_} = $locus;
	$source_lookup{$_} = $source;
	if ($strand eq "+") {$base_position_as_percentile = get_position_as_percentile_pos($_);}
	elsif ($strand eq "-") {$base_position_as_percentile = get_position_as_percentile_neg($_);}
	$base_as_centile_of_coding{$_}= $base_position_as_percentile;
	}
}

elsif ($source eq "rRNA")
	{
	@range = ($start..$stop);
	$length = ($stop-$start)+1;

	
	$length_lookup{$locus} = $length;
	$start_lookup{$locus}= $start;
	$stop_lookup{$locus}= $stop;
	foreach (@range)
	{
	chomp $_;
	if ($locus ne "NA") 
		{
		$universal_id{$_} = $locus;
		$univeral_id_keys{$locus} = 1;
		$universal_id_lookup_gene{$locus} = $gene;
		$universal_id_lookup_start{$locus} = $start;
		$universal_id_lookup_stop{$locus} = $stop;
		$universal_id_lookup_length{$locus} = $length;
		$universal_id_lookup_product{$locus} = $product;
		$universal_id_lookup_strand{$locus} = $strand;
		}
	else {
		$gene = "$product\_$start";
		$universal_id{$_} = $gene;
		$univeral_id_keys{$gene} = 1;
		$universal_id_lookup_gene{$gene} = $gene;
		$universal_id_lookup_start{$gene} = $start;
		$universal_id_lookup_stop{$gene} = $stop;
		$universal_id_lookup_length{$gene} = $length;
		$universal_id_lookup_product{$gene} = $product;
		$universal_id_lookup_strand{$gene} = $strand;
		}
		
	$gene_lookup{$_} = $gene;
	$product_lookup{$_} = $product;
	$locus_lookup{$_} = $locus;
	$source_lookup{$_} = $source;
	if ($strand eq "+") {$base_position_as_percentile = get_position_as_percentile_pos($_);}
	elsif ($strand eq "-") {$base_position_as_percentile = get_position_as_percentile_neg($_);}
	$base_as_centile_of_coding{$_}= $base_position_as_percentile;
	}
}

elsif ($source eq "tRNA")
	{
	@range = ($start..$stop);
	$length = ($stop-$start)+1;
	$length_lookup{$locus} = $length;
	$start_lookup{$locus}= $start;
	$stop_lookup{$locus}= $stop;
	foreach (@range)
	{
	chomp $_;
		if ($locus ne "NA") 
		{
		$universal_id{$_} = $locus;
		$univeral_id_keys{$locus} = 1;
		$universal_id_lookup_gene{$locus} = $gene;
		$universal_id_lookup_start{$locus} = $start;
		$universal_id_lookup_stop{$locus} = $stop;
		$universal_id_lookup_length{$locus} = $length;
		$universal_id_lookup_product{$locus} = $product;
		$universal_id_lookup_strand{$locus} = $strand;
		}
	else {
		$universal_id{$_} = $gene;
		$univeral_id_keys{$gene} = 1;
		$universal_id_lookup_gene{$gene} = $gene;
		$universal_id_lookup_start{$gene} = $start;
		$universal_id_lookup_stop{$gene} = $stop;
		$universal_id_lookup_length{$gene} = $length;
		$universal_id_lookup_product{$gene} = $product;
		$universal_id_lookup_strand{$gene} = $strand;
		}
	
	$gene_lookup{$_} = $gene;
	$product_lookup{$_} = $product;
	$locus_lookup{$_} = $locus;
	$source_lookup{$_} = $source;
	if ($strand eq "+") {$base_position_as_percentile = get_position_as_percentile_pos($_);}
	elsif ($strand eq "-") {$base_position_as_percentile = get_position_as_percentile_neg($_);}
	$base_as_centile_of_coding{$_}= $base_position_as_percentile;
	}
}
}
close GTF;
my @universal_ids = keys %univeral_id_keys;
my @sorted_universal_ids = sort {$a cmp $b} @universal_ids;
@universal_ids = ();

#################################################################################################################
# PROCESS GENOME FASTA FILE
# for each insertion position, the base at the insertion site is determined. This is compared to the composition
# of the genome to detrmin bias in insertion position
#################################################################################################################

$time = scalar localtime;
print "Starting parsing genome file\t$time\n"; 

open FASTA, $genome;
my %genome_base;
my $genome_genome_seq_id;
my @bases = ();
{
local $/ = '>'; 
<FASTA>;

while (<FASTA>) {       
    chomp $_;
    my ($seq_id, @sequence) = split "\n";
    $genome_genome_seq_id = $seq_id;
    my $fasta_sequence = join '',@sequence;
    @bases = split(//, $fasta_sequence);
}
}
close FASTA;
my $current_position_hold = 1;
my $genome_length = scalar @bases;


my $genome_base_count_A = 0;
my $genome_base_count_C = 0;
my $genome_base_count_G = 0;
my $genome_base_count_T = 0;

foreach (@bases)
	{
	chomp $_;
	$genome_base{$current_position_hold} = $_;
	if ($_ =~ /[Aa]/){$genome_base_count_A++;}
	elsif ($_ =~ /[Cc]/){$genome_base_count_C++;}
	elsif ($_ =~ /[Gg]/){$genome_base_count_G++;}
	elsif ($_ =~ /[Tt]/){$genome_base_count_T++;}
	$current_position_hold++;
	}
@bases = ();

my $percent_genome_base_count_A = sprintf("%.1f", (($genome_base_count_A / $genome_length)*100));
my $percent_genome_base_count_C = sprintf("%.1f", (($genome_base_count_C / $genome_length)*100));
my $percent_genome_base_count_G = sprintf("%.1f", (($genome_base_count_G / $genome_length)*100));
my $percent_genome_base_count_T = sprintf("%.1f", (($genome_base_count_T / $genome_length)*100));


#################################################################################################################
# PROCESS POSITION DEPTH FILE
#################################################################################################################


$time= localtime;		
print "Starting processing depth file\t$time\n";

open DEPTH, "$depth_file";
<DEPTH>; # remove header
my @positions_hit = ();
my $total_mapped_read_count = 0; # tally of all reads mapped (sum of depths at all positions)

my %depth_at_position; # key is position ==> depth

while (<DEPTH>)
{
chomp $_;
my ($position, $depth) = split '\t', $_;

# only keep a tally of those above minimum coverage.
if ($depth >= $minimum_coverage)
	{
	push @positions_hit, $position;
	$total_mapped_read_count = ($total_mapped_read_count+$depth);
	$depth_at_position{$position} = $depth;
	}
}
close DEPTH;

my $unique_positions_count = scalar @positions_hit; # number of uniq positions (lines in input depth file)

my $depth_file_short = $depth_file;
if ($depth_file =~ /.*?\/(.*)/){$depth_file_short = $1;}


my $expected_insertion_count = ($total_mapped_read_count / $unique_positions_count);
my $expected_insertion_proportion = (1 / $unique_positions_count);

print LOG "\n===============================================================================================================\n";
print LOG "Position depth file processed\:$depth_file_short\n";
print LOG "Genome size (bp)\:$genome_length\n";

print LOG "Expected insert count\:$expected_insertion_count \($total_mapped_read_count \/ $unique_positions_count\)\n";
print LOG "Normalised insertion index (NIindex) calculated as observed insert count per position - Expected insert count per position\n";
print LOG "If Observed insertions = Expected insertions NIindex will equal 0\n\n";
print LOG "Expected insert proportion\:$expected_insertion_proportion = \(1 / $unique_positions_count)\n";
print LOG "Observed insert proportion\:(read count at position / total mapped reads\)\n";
print LOG "===============================================================================================================\n";



$time = scalar localtime;
print "Processing insertion points\t$time\n"; 

#################################################################################################################
# PROCESS ALL INSERTION POINTS
#################################################################################################################

my %all_hit_counts; # key is CDS/tRNA/rRNA ==> number of indivual insertions not depth
my %all_hit_counts_position; # key is coordinate ==> 

foreach(@positions_hit)
	{
	chomp $_;
	my $insertion_point = $_;
	
	my $universal_id_hit = "NA";
	
	if (exists $universal_id{$insertion_point}) {$universal_id_hit = $universal_id{$insertion_point};}
	
	if (exists $all_hit_counts{$universal_id_hit})
		{
		my $current = $all_hit_counts{$universal_id_hit} + $depth_at_position{$insertion_point};
		$all_hit_counts{$universal_id_hit}= $current;
		}
		else {
			$all_hit_counts{$universal_id_hit} = $depth_at_position{$insertion_point};
		}
	}

open INSERTION_DEPTH, ">$name.PIMMS.counts.min_cov\.$minimum_coverage.insertion.positions.depths";
print INSERTION_DEPTH "Insertion_Position\tNumber_of_reads_at_position\tNIindex\tObserved_proportion_of_mapped_reads\tNIPdiff\tNIPratio\tGene\tProduct\tLocus\tSource\tPosition\(Centile_of_gene\)\n";

my @depth_above_min_data = ();
my @unique_positions_hit_gt_minimum_coverage = ();

print LOG "Normalised insertion proportion (NIPdiff) calculated as observed insert proportion - expected insert proportion\n";
print LOG "If Observed proportion = Expected proportion NIPdiff will equal 0\n";
print LOG "Normalised insertion proportion (NIPratio) calculated as observed insert proportion / expected insert proportion\n";
print LOG "If Observed proportion = Expected proportion NIPratio will equal 1\n";

foreach (@positions_hit)
	{
	chomp $_;
	if ($depth_at_position{$_} >= $minimum_coverage)
		{
		my $NIindex =  sprintf("%.5f", ($depth_at_position{$_} - $expected_insertion_count));
		my $observed_proportion =  ($depth_at_position{$_} / $total_mapped_read_count);
		my $NIPdiff =  sprintf("%.5f", ($observed_proportion - $expected_insertion_proportion)); 
		my $NIPratio =  sprintf("%.5f", ($observed_proportion / $expected_insertion_proportion)); 
		my $gene_at_position = "NA";
		my $product_at_position = "NA";
		my $locus_at_position = "NA";
		my $source_at_position = "NA";
		my $base_centile_at_position = "NA";
		
		if (exists $gene_lookup{$_}) {$gene_at_position = $gene_lookup{$_}};
		if (exists $product_lookup{$_}) {$product_at_position = $product_lookup{$_}};
		if (exists $locus_lookup{$_}) {$locus_at_position = $locus_lookup{$_}};
		if (exists $source_lookup{$_}) {$source_at_position = $source_lookup{$_}};
		if (exists $base_as_centile_of_coding{$_}){$base_centile_at_position = $base_as_centile_of_coding{$_}};
				
		print INSERTION_DEPTH "$_\t$depth_at_position{$_}\t$NIindex\t$observed_proportion\t$NIPdiff\t$NIPratio\t$gene_at_position\t$product_at_position\t$locus_at_position\t$source_at_position\t$base_centile_at_position\n";
		push @depth_above_min_data, $depth_at_position{$_};
		push @unique_positions_hit_gt_minimum_coverage, $_;
		}
	}
close INSERTION_DEPTH;

my @depth_above_min_data_descriptive_stats = desc_stats(@depth_above_min_data);


print LOG "Coverage Descriptive statistics for positions >= $minimum_coverage depth\:\nCoverage count\:$depth_above_min_data_descriptive_stats[0]\nMean coverage\:\t$depth_above_min_data_descriptive_stats[1]\nMedian coverage\:\t$depth_above_min_data_descriptive_stats[2]\nMinimum coverage\:\t$depth_above_min_data_descriptive_stats[3]\nMaximum coverage\:\t$depth_above_min_data_descriptive_stats[4]\n";

#################################################################################################################
# PROCESS UNIQUE INSERTION POINTS
#################################################################################################################

open DIST_BETWEEN_UNIQ_INSERTIONS, ">$name\.PIMMS\.counts\.min_cov\.$minimum_coverage\.unique.insertion.inter.distances";
open UNIQ_INSERTION_CENTILE, ">$name\.PIMMS\.counts\.min_cov\.$minimum_coverage\.unique.insertion.centile.positions";

print LOG "===============================================================================================================\n";
print LOG "\nCentile position of each unique insertion above $minimum_coverage depth\: foreach unique insertion position \($depth_above_min_data_descriptive_stats[0] positions\) if in an annotated CDS, tRNA or rRNA the insertion position as a centile of the annotated element is given in PIMMS\.counts\.min_cov\.$minimum_coverage\.unique.insertion.centile.positions\.\n===============================================================================================================\n";


my $insertion_base_A_count = 0;
my $insertion_base_C_count = 0;
my $insertion_base_G_count = 0;
my $insertion_base_T_count = 0;
my $current_position_in_array = 0;
my @inter_uniq_distance = ();

my %uniq_hit_counts; # lookup of universal id and total number of unique insertion hits. 
my %percentile_positions_hash_of_arrays; # key is universal id array is percentile position of all uniq insertions

foreach(@unique_positions_hit_gt_minimum_coverage)
	{
	chomp $_;
	my $insertion_point = $_;
	my $universal_id_hit = "NA";
	
	if (exists $universal_id{$insertion_point}) {$universal_id_hit = $universal_id{$insertion_point};}
	
	
	if (exists $uniq_hit_counts{$universal_id_hit})
		{
		my $current = $uniq_hit_counts{$universal_id_hit};
		$current++;
		$uniq_hit_counts{$universal_id_hit}= $current;
		}
		else {$uniq_hit_counts{$universal_id_hit} = 1;}
	
	my $insertion_base = $genome_base{$insertion_point};
	
	if ($insertion_base =~ /[Aa]/){$insertion_base_A_count++;}
	elsif ($insertion_base =~ /[Cc]/){$insertion_base_C_count++;}
	elsif ($insertion_base =~ /[Gg]/){$insertion_base_G_count++;}
	elsif ($insertion_base =~ /[Tt]/){$insertion_base_T_count++;}
	
	if (exists $unique_positions_hit_gt_minimum_coverage[$current_position_in_array+1])
		{
		my $inter_insertion_dist = ($unique_positions_hit_gt_minimum_coverage[$current_position_in_array+1] - $unique_positions_hit_gt_minimum_coverage[$current_position_in_array]);
		print DIST_BETWEEN_UNIQ_INSERTIONS "$inter_insertion_dist\n";
		push @inter_uniq_distance, $inter_insertion_dist;
		}
	
	if (exists $base_as_centile_of_coding{$insertion_point})
		{
		unless ($base_as_centile_of_coding{$insertion_point} eq "NA")
			{
			print UNIQ_INSERTION_CENTILE "$base_as_centile_of_coding{$insertion_point}\n";
			push (@{$percentile_positions_hash_of_arrays{$universal_id_hit}}, $base_as_centile_of_coding{$insertion_point});
			}
		}
	$current_position_in_array++;
	}

my $percent_insertion_base_count_A = sprintf("%.1f", (($insertion_base_A_count / $depth_above_min_data_descriptive_stats[0])*100));
my $percent_insertion_base_count_C = sprintf("%.1f", (($insertion_base_C_count / $depth_above_min_data_descriptive_stats[0])*100));
my $percent_insertion_base_count_G = sprintf("%.1f", (($insertion_base_G_count / $depth_above_min_data_descriptive_stats[0])*100));
my $percent_insertion_base_count_T = sprintf("%.1f", (($insertion_base_T_count / $depth_above_min_data_descriptive_stats[0])*100));

print LOG "Base composition of unique insertion sites\nInsertion base A\t$insertion_base_A_count\t$percent_insertion_base_count_A\%\n";
print LOG "Insertion base C\t$insertion_base_C_count\t$percent_insertion_base_count_C\%\n";
print LOG "Insertion base G\t$insertion_base_G_count\t$percent_insertion_base_count_G\%\n";
print LOG "Insertion base T\t$insertion_base_T_count\t$percent_insertion_base_count_T\%\n";

print LOG "Base composition of Genome\nGenome base A\t$genome_base_count_A\t$percent_genome_base_count_A\%\n";
print LOG "Genome base C\t$genome_base_count_C\t$percent_genome_base_count_C\%\n";
print LOG "Genome base G\t$genome_base_count_G\t$percent_genome_base_count_G\%\n";
print LOG "Genome base T\t$genome_base_count_T\t$percent_genome_base_count_T\%\n";

close DIST_BETWEEN_UNIQ_INSERTIONS;
close UNIQ_INSERTION_CENTILE;

if (exists $inter_uniq_distance[0])
	{
	my @uniq_insert_descriptive_stats = desc_stats(@inter_uniq_distance);
	print LOG "===============================================================================================================\nDistribution of distances between unique insertion positons above $minimum_coverage depth \(bp\)\:\nCount\:$uniq_insert_descriptive_stats[0]\nMean inter unique insertion distance\:\t$uniq_insert_descriptive_stats[1]\nMedian inter unique insertion distance\:\t$uniq_insert_descriptive_stats[2]\nMinimum inter unique insertion distance\:\t$uniq_insert_descriptive_stats[3]\nMaximum inter unique insertion distance\:\t$uniq_insert_descriptive_stats[4]\n";
	print LOG "===============================================================================================================\n";
	}
else {
	print LOG "===============================================================================================================\nDistribution of distances between unique insertion positons above $minimum_coverage depth \(bp\)\:\nCount\:NA\nMean inter unique insertion distance\:\tNA\nMedian inter unique insertion distance\:\tNA\nMinimum inter unique insertion distance\:\tNA\nMaximum inter unique insertion distance\:\tNA\n";
	print LOG "===============================================================================================================\n";
	}
#~ #################################################################################################################
#~ # GENERATE OUTPUT TABLES
#~ #################################################################################################################

print LOG "OUTPUT TABLES\n";
print LOG "Table of all CDS, tRNA and rRNA with insertion number etc in Summary.Tables\/$name\.PIMMS\.counts\.min_cov\.$minimum_coverage\.summary.table\n";
print LOG "Normalised Reads Mapped \(NRM_score\) is calculated as (total number of reads mapped/length of gene in KB)/(total mapped read count/10^6)\n"; 
print LOG "Normalised Insertions Mapped \(NIM_score\) is calculated as (total number of unique insertions mapped/length of gene in KB)/(total mapped read count/10^6)\n";
print LOG "Table of all per position insertions NIindex etc in Insertion.distances.and.depths\/$name.PIMMS.counts.min_cov\.$minimum_coverage.insertion.positions.depths\n";
print LOG "===============================================================================================================\n\n";


open OUT_TABLE, ">$name\.PIMMS\.counts\.min_cov\.$minimum_coverage\.summary.table";
print OUT_TABLE "Locus\tGene\tStart\tStop\tCDS_length\tProduct\tTotal_number_of_insertions\tNumber_of_unique_insertion_positions\(\>=$minimum_coverage x coverage\)\tUnique_insertions_per1KbCDS\(\>=$minimum_coverage x coverage\)\tFirst_unique_insertion_centile_position\(\>=$minimum_coverage x coverage\)\tLast_unique_insertion_centile_position\(\>=$minimum_coverage x coverage\)\tNormalised_Reads_Mapped \(NRM_score\)\tNormalised_Insertions_Mapped \(NIM_score\)\n";

my $total_univeral_ids = scalar @sorted_universal_ids;

foreach (@sorted_universal_ids)
	{
	chomp $_;
	my $id_processing = $_;
	
	if ($id_processing eq "NA"){}
	
	else {
	my $hits_per_kb = 0;
	my $uniq_insertion_number = 0;
	my $total_insertion_number = 0;
	my $first_centile_position = "NA";
	my $last_centile_position = "NA";
	
	my $NRM = 0; # Normalised Reads Mapped\(NRM_score\) is calculated as (total number of reads mapped/length of gene in KB)/(total mapped read count/1000000)\n"; 
	my $NIM = 0; # Normalised Insertions Mapped\(NIM_score\) is calculated as (total number of unique insertions mapped/length of gene in KB)/(total mapped read count/1000000)\n";
	
	if (exists $uniq_hit_counts{$id_processing}) {$uniq_insertion_number = $uniq_hit_counts{$id_processing};}
	if (exists $all_hit_counts{$id_processing}) {$total_insertion_number = $all_hit_counts{$id_processing};}
	if (exists $percentile_positions_hash_of_arrays{$id_processing})
		{
		my @processing = @{$percentile_positions_hash_of_arrays{$id_processing}};
		my @sorted_processing = sort {$a <=> $b} @processing;
		$first_centile_position = $sorted_processing[0];
		$last_centile_position = pop @sorted_processing;
		}
		
	if ($uniq_insertion_number > 0 && $universal_id_lookup_length{$id_processing} > 0)
		{
		$hits_per_kb = sprintf("%.3f",(($uniq_hit_counts{$id_processing}/$universal_id_lookup_length{$id_processing})*1000));
		}
	
	if (exists $all_hit_counts{$id_processing})
		{
		$NRM =  sprintf("%.3f", (($total_insertion_number/($universal_id_lookup_length{$id_processing}/1000))/($total_mapped_read_count/1000000)));
		}
	if (exists $uniq_hit_counts{$id_processing})
		{
		$NIM =  sprintf("%.3f", (($uniq_hit_counts{$id_processing}/($universal_id_lookup_length{$id_processing}/1000))/($total_mapped_read_count/1000000)));
		}	
		
	
	print OUT_TABLE "$id_processing\t$universal_id_lookup_gene{$id_processing}\t$universal_id_lookup_start{$id_processing}\t$universal_id_lookup_stop{$id_processing}\t$universal_id_lookup_length{$id_processing}\t$universal_id_lookup_product{$id_processing}\t$total_insertion_number\t$uniq_insertion_number\t$hits_per_kb\t$first_centile_position\t$last_centile_position\t$NRM\t$NIM\n";
	}
}
close OUT_TABLE;



#~ #################################################################################################################
#~ # GENERATE R scripts for plots if more than one point of insertion. 
#~ #################################################################################################################

if (exists $inter_uniq_distance[0])
	{
open R_PLOTS, ">$name\.PIMMS.counts.$minimum_coverage\.plots.script.R";

my $Rscript_text = "
# PIMMS counts output processing
inter.unique.insertion.dist <- read.table(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.unique.insertion.inter.distances\")
data1 <- inter.unique.insertion.dist[,1]
pdf(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.inter.insertion.distances.histogram.pdf\")
hist(data1, main=\"$name inter-insertion distance\", lwd = 3, col=rgb(1,0,0,0.4), xlab = \"Inter unique insertion distance (bp)\")
dev.off()

unique.insertion.centile <- read.table(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.unique.insertion.centile.positions\")
data2 <- unique.insertion.centile[,1]
pdf(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.unique.insertion.centile.positions.histogram.pdf\")
hist(data2, main=\"$name unique insertion centile positions\", lwd = 3, col=rgb(1,0,0,0.4), xlab = \"Position centile\")
dev.off()

read.depth <- read.table(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.depths\", skip= 1, sep = \'\t\', quote = \"\")
x <- read.depth[,1]
y <- read.depth[,2]
smoothingSpline = smooth.spline(x, y, spar=0.3)
pdf(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.depths.pdf\")
plot (x,y , main = \"$name insertion read depth\", xlab = \"Genome position\", ylab = \"Read Depth\", xlim = c(1,$genome_length))
lines(smoothingSpline, col='green', lwd=2)
dev.off()

z <- read.depth[,3]
smoothingSpline = smooth.spline(x, z, spar=0.3)
pdf(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.NIindex.pdf\")
plot (x,z, main = \"$name NIindex \(red line\=expected count\)\", xlab = \"Genome position\", ylab = \"NIindex\", xlim = c(1,$genome_length))
lines(smoothingSpline, col='green', lwd=2)
abline(h=$expected_insertion_count,col='red',lty=2, lwd=2)
dev.off()

upper_bound <- 5 * $expected_insertion_count
lower_bound <- -1*(5 * $expected_insertion_count)
pdf(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.NIindex.Zoom.pdf\")
plot (x,z, main = \"$name NIindex \(red line\=expected count\)\", xlab = \"Genome position\", ylab = \"NIindex\", xlim = c(1,$genome_length), ylim = c(lower_bound,upper_bound))
lines(smoothingSpline, col='green', lwd=2)
abline(h=$expected_insertion_count,col='red',lty=2, lwd=2)
dev.off()


read.depth <- read.table(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.depths\", skip= 1, sep = \'\t\', quote = \"\")
x <- read.depth[,1]
y1 <- read.depth[,5]
smoothingSpline = smooth.spline(x, y1, spar=0.1)
pdf(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.NIPdiff.pdf\")
plot (x,y1, main = \"$name NIPdiff \(red line\=expected proportion\)\", xlab = \"Genome position\", ylab = \"Normalised insertion proportion (NIPdiff)\", xlim = c(1,$genome_length))
lines(smoothingSpline, col='green', lwd=2)
abline(h=$expected_insertion_proportion,col='red',lty=2, lwd=2)
dev.off()

upper_bound <- 5  *$expected_insertion_proportion
lower_bound <- -1*(5 * $expected_insertion_proportion)
pdf(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.NIPdiff.zoom.pdf\")
plot (x,y1, main = \"$name NIPdiff \(red line\=expected proportion\)\", xlab = \"Genome position\", ylab = \"Normalised insertion proportion (NIPdiff)\", xlim = c(1,$genome_length), ylim = c(lower_bound,upper_bound))
lines(smoothingSpline, col='green', lwd=2)
abline(h=$expected_insertion_proportion,col='red',lty=2, lwd=2)
dev.off()


read.depth <- read.table(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.depths\", skip= 1, sep = \'\t\', quote = \"\")
x <- read.depth[,1]
y2 <- read.depth[,6]
smoothingSpline = smooth.spline(x, y2, spar=0.1)
pdf(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.NIPratio.pdf\")
plot (x,y2, main = \"$name NIPratio \(red line\=expected proportion\)\", xlab = \"Genome position\", ylab = \"Normalised insertion proportion (NIPratio)\", xlim = c(1,$genome_length))
lines(smoothingSpline, col='green', lwd=2)
abline(h=$expected_insertion_proportion,col='red',lty=2, lwd=2)
dev.off()

upper_bound <- 10
lower_bound <- 0
pdf(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.NIPratio.zoom.pdf\")
plot (x,y2, main = \"$name NIPratio \(red line\=expected proportion\)\", xlab = \"Genome position\", ylab = \"Normalised insertion proportion (NIPratio)\", xlim = c(1,$genome_length), ylim = c(lower_bound,upper_bound))
lines(smoothingSpline, col='green', lwd=2)
abline(h=$expected_insertion_proportion,col='red',lty=2, lwd=2)
dev.off()

# distributions of NRM & NIM scores
summary.in <- read.table(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.summary.table\", header = TRUE, sep = \'\t\', na.strings = \"NA\", quote = \"\")
NRM <- summary.in[,12]
NIM <- summary.in[,13]
logNRM <- log(NRM)
logNIM <- log(NIM)
pdf(\"$name\.PIMMS.counts.min_cov.$minimum_coverage.summary.plots.pdf\")
par(mfrow=c(2,2))
hist(NRM, main=\"Histogram $name NRM\", lwd = 3, col=rgb(1,0,0,0.4), xlab = \"NRM\")
hist(NIM, main=\"Histogram $name NIM\", lwd = 3, col=rgb(1,0,0,0.4), xlab = \"NIM\")
hist(logNRM, col=rgb(1,0,0,0.4), main=\"natural log transformed NRM\")
hist(logNIM, col=rgb(1,0,0,0.4), main=\"natural log transformed NIM\")
dev.off()

";
print R_PLOTS "$Rscript_text\n";
close R_PLOTS;	
system "R --vanilla --quiet < $name\.PIMMS.counts.$minimum_coverage\.plots.script.R > R.tmp.out";
unless (-d "Coverage.and.Distribution.Plots"){system "mkdir Coverage.and.Distribution.Plots";}
system "mv $name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.NIPdiff.pdf $name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.NIPdiff.zoom.pdf $name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.NIPratio.pdf $name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.NIPratio.zoom.pdf $name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.NIindex.Zoom.pdf $name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.NIindex.pdf $name\.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.depths.pdf $name\.PIMMS.counts.min_cov.$minimum_coverage.summary.plots.pdf $name\.PIMMS.counts.min_cov.$minimum_coverage.inter.insertion.distances.histogram.pdf $name\.PIMMS.counts.min_cov.$minimum_coverage.unique.insertion.centile.positions.histogram.pdf Coverage.and.Distribution.Plots\/";
system "rm -rf R.tmp.out tmp ./.Rhistory";
unless (-d "R.scripts"){system "mkdir R.scripts";}
system "mv $name.PIMMS.counts.$minimum_coverage.plots.script.R R.scripts\/"; 
}

$time = localtime;	
print LOG "Finished\: $time\n";
close LOG;


unless (-d "Insertion.distances.and.depths"){system "mkdir Insertion.distances.and.depths";}
system "mv $name.PIMMS.counts.min_cov.$minimum_coverage.unique.insertion.centile.positions $name.PIMMS.counts.min_cov.$minimum_coverage.insertion.positions.depths $name.PIMMS.counts.min_cov.$minimum_coverage.unique.insertion.inter.distances Insertion.distances.and.depths\/";

unless (-d "Summary.Tables"){system "mkdir Summary.Tables";}
system "mv $name.PIMMS.counts.min_cov.$minimum_coverage.summary.table Summary.Tables\/"; 



print "Finished\: $time\n";


#################################################################################################################
# SUBROUTINES
#################################################################################################################

sub get_position_as_percentile_pos{
my $in = $_;
my $in_locus  = $locus_lookup{$_};
my $in_length = $length_lookup{$in_locus};
my $in_start = $start_lookup{$in_locus};
my $percentile =  sprintf("%.1f", ((($in-$in_start)+1) / ($in_length/100)));
return $percentile;
}

sub get_position_as_percentile_neg{
my $in = $_;
my $in_locus  = $locus_lookup{$_};
my $in_length = $length_lookup{$in_locus};
my $in_stop = $stop_lookup{$in_locus};
my $percentile =  sprintf("%.1f", ((($in_stop-$in)+1) / ($in_length/100)));
return $percentile;
}

sub get_seq{
my @in = @_;
my @holding = ();
foreach (@in) {
	chomp $_;
	push @holding, $genome_base{$_}
	}
my $returned = join '', @holding;
return $returned;
}

sub uniq_array{
##### make a unique list from the @genes array
my @in = @_;
my %seen = ();
my @uniq = ();
foreach (@in)
{chomp $_;
unless ($seen{$_}){
$seen{$_} = 1;
push (@uniq, $_);
}
}

return @uniq;
}


sub desc_stats{
    my @in= @_;
    my @vals = @in;
    my $len = 1;
    
    
    if (exists $vals[0])
	{
	my $sum = $vals[0];
	my @desc_stats = (); #will contain --- count mean median min max
	    
	    if (exists $in[1])
		{
		@vals = sort {$a <=> $b} @in;
		$len = @vals;
		}
		
		push @desc_stats, $len;

		if (exists $in[1])
		{
		$sum = eval join '+', @in;
		}
		
		my $mean = ($sum/$len);
		push @desc_stats, $mean;
	    
	    if($len%2) #odd?
	    {
		push @desc_stats, $vals[int($len/2)];
	    }
	    else #even
	    {
		push @desc_stats, ($vals[int($len/2)-1] + $vals[int($len/2)])/2;
	    }
		push @desc_stats, $vals[0];
		my $last = pop @vals;
		push @desc_stats, $last;
	return @desc_stats;
	}
	}
}

####################################################################################################
#
# PIMMS COMPARE MODULE START
#
####################################################################################################
if ($module eq "compare")
{
my $compare_usage = "===============================================================================================================
PIMMS compare: identifies matching positions between input and output pool data. 
=============================================================================================================== 
USAGE:  

-in	Parsed input sample PIMMS.counts.min_cov.x.insertion.positions.depths output from PIMMS.counts module
	will be in \"Insertion.distances.and.depths\" diretory)
-out	Parsed output sample PIMMS.counts.min_cov.x.insertion.positions.depths output from PIMMS.counts module
	will be in \"Insertion.distances.and.depths\" diretory)
-dist	Exact distance to collapse reads for overlap (number of bp or N to switch off)
-n	Comparison short name (keep short no spaces)
===============================================================================================================
" ;

if( ! defined $input) {
print "$compare_usage\nWARNING: Cannot proceed without input position depth file\n\n"; exit;
}
if( ! defined $output) {
print "$compare_usage\nWARNING: Cannot proceed without output position depth file\n\n"; exit;
}
if( ! defined $name) {
print "$compare_usage\nWARNING: Cannot proceed without short name for comparison\n\n"; exit;
}
if( ! defined $distance_to_collapse) {
print "$compare_usage\nWARNING: Cannot proceed without exact distance to collapse or N\n\n"; exit;
}


my $coverage = "NA";
if ($input =~/.*\_cov\.(\d+)\.*/)
{
$coverage = $1;
}


#############################################################################################################################
#READ IN FILES AND MATCH POSITIONS
#############################################################################################################################

my $time = scalar localtime;
print "\nParsing files\t$time\n"; 	

open INPUT, $input;
my %input_details; # hash of arrays key is position array is details == Number_of_reads_at_position NIindex Observed_proportion_of_mapped_reads NIPdiff NIPratio Gene Product Locus Source Position(Centile_of_gene)
<INPUT>; # remove header
my @input_positions = ();

while (<INPUT>)
	{
	chomp $_;
	my ($key, @details) = split '\t', $_;
	$input_details{$key} = [ @details ];
	push @input_positions, $key;
	}
	
open OUTPUT, $output;
my %output_details; # hash of arrays key is position array is details == Number_of_reads_at_position NIindex Observed_proportion_of_mapped_reads NIPdiff NIPratio Gene Product Locus Source Position(Centile_of_gene)
<OUTPUT>; # remove header
my @output_positions = ();
while (<OUTPUT>)
	{
	chomp $_;
	my ($key, @details) = split '\t', $_;
	$output_details{$key} = [ @details ];
	push @output_positions, $key;
	}


open OUTFILE, ">$name\.coverage\.$coverage\.PIMMS\.IO\.d$distance_to_collapse\.shared.position.table";
print OUTFILE "Position\tInput_insertion_count\tOutput_insertion_count\tInput_observed_proportion_of_reads\tOutput_observed_proportion_of_reads\tProportion_diff\tProportion_ratio\tGene\tProduct\tLocus\tSource\tPosition(Centile_of_gene)\tZscore\tFlag\n";

open OUTFILE2, ">$name\.coverage\.$coverage\.PIMMS\.IO\.d$distance_to_collapse\.Input_only.position.table";
print OUTFILE2 "Position\tInput_insertion_count\tOutput_insertion_count\tInput_observed_proportion_of_reads\tOutput_observed_proportion_of_reads\tProportion_diff\tProportion_ratio\tGene\tProduct\tLocus\tSource\tPosition(Centile_of_gene)\n";

open OUTFILE3, ">$name\.coverage\.$coverage\.PIMMS\.IO\.d$distance_to_collapse\.Output_only.position.table";
print OUTFILE3 "Position\tInput_insertion_count\tOutput_insertion_count\tInput_observed_proportion_of_reads\tOutput_observed_proportion_of_reads\tProportion_diff\tProportion_ratio\tGene\tProduct\tLocus\tSource\tPosition(Centile_of_gene)\n";


my $input_only = 0;
my $shared_positions = 0;
my $output_only = 0;


my %shared_position_data;
my @shared_positions = ();
my @shared_proportion_ratios = ();
my $collapsed_position_matched = 0;



foreach (@input_positions)
		{
		chomp $_;
		my $position = $_;
		my $flag = 0;
		
		
		if (exists $output_details{$position})
			{
			my @input_data = @{$input_details{$position}};
			my $input_NIindex = $input_data[1]; # NIindex
			my $input_observed_prop_of_reads = sprintf ("%.8f", ($input_data[2])); #Observed_proportion_of_mapped_reads
			my @output_data = @{$output_details{$position}};
			my $output_NIindex = $output_data[1]; # NIindex
			my $output_observed_prop_of_reads = sprintf ("%.8f", ($output_data[2])); #Observed_proportion_of_mapped_reads
			
			my $NIdiff = sprintf ("%.6f", ($input_NIindex - $output_NIindex));
			my $Obs_prop_diff = sprintf ("%.8f", ($input_observed_prop_of_reads- $output_observed_prop_of_reads));
			my $Obs_prop_ratio = sprintf ("%.8f", ($output_observed_prop_of_reads / $input_observed_prop_of_reads));
			
			my $data_line = "$position\t$input_data[0]\t$output_data[0]\t$input_observed_prop_of_reads\t$output_observed_prop_of_reads\t$Obs_prop_diff\t$Obs_prop_ratio\t$input_data[5]\t$input_data[6]\t$input_data[7]\t$input_data[8]\t$input_data[9]";
			$shared_position_data{$position} = $data_line;
			push @shared_positions, $position;
			push @shared_proportion_ratios, $Obs_prop_ratio;
			$shared_positions++;
			$flag = 1;
			}
			
			
		elsif ($distance_to_collapse =~ /\d+/)
			{
				my $collapse_position1 = ($position+$distance_to_collapse);
				my $collapse_position2 = ($position-$distance_to_collapse);
				
				

				if (exists $output_details{$collapse_position1})
					{
					my @input_data = @{$input_details{$position}};
					my $input_NIindex = $input_data[1];
					my $input_observed_prop_of_reads = sprintf ("%.8f", ($input_data[2]));
					my @output_data = @{$output_details{$collapse_position1}};
					my $output_NIindex = $output_data[1];
					my $output_observed_prop_of_reads = sprintf ("%.8f", ($output_data[2]));
					
					my $NIdiff = sprintf ("%.8f", ($input_NIindex - $output_NIindex));
					my $Obs_prop_diff = sprintf ("%.8f", ($input_observed_prop_of_reads- $output_observed_prop_of_reads));
					my $Obs_prop_ratio = sprintf ("%.8f", ($output_observed_prop_of_reads / $input_observed_prop_of_reads));
					
					my $data_line = "$position\t$input_data[0]\t$output_data[0]\t$input_observed_prop_of_reads\t$output_observed_prop_of_reads\t$Obs_prop_diff\t$Obs_prop_ratio\t$input_data[5]\t$input_data[6]\t$input_data[7]\t$input_data[8]\t$input_data[9]";
					$shared_position_data{$position} = $data_line;
					push @shared_positions, $position;
					push @shared_proportion_ratios, $Obs_prop_ratio;
					$shared_positions++;
					$collapsed_position_matched++;
					$flag = 1;
					}
					
				if (exists $output_details{$collapse_position2})
					{
					my @input_data = @{$input_details{$position}};
					my $input_NIindex = $input_data[1];
					my $input_observed_prop_of_reads = sprintf ("%.8f", ($input_data[2]));
					my @output_data = @{$output_details{$collapse_position2}};
					my $output_NIindex = $output_data[1];
					my $output_observed_prop_of_reads = sprintf ("%.8f", ($output_data[2]));
					
					my $NIdiff = sprintf ("%.8f", ($input_NIindex - $output_NIindex));
					my $Obs_prop_diff = sprintf ("%.8f", ($input_observed_prop_of_reads-$output_observed_prop_of_reads));
					my $Obs_prop_ratio = sprintf ("%.8f", ($output_observed_prop_of_reads / $input_observed_prop_of_reads));
					
					my $data_line = "$position\t$input_data[0]\t$output_data[0]\t$input_observed_prop_of_reads\t$output_observed_prop_of_reads\t$Obs_prop_diff\t$Obs_prop_ratio\t$input_data[5]\t$input_data[6]\t$input_data[7]\t$input_data[8]\t$input_data[9]";
					$shared_position_data{$position} = $data_line;
					push @shared_positions, $position;
					push @shared_proportion_ratios, $Obs_prop_ratio;
					$shared_positions++;
					$collapsed_position_matched++;
					$flag = 1;
					}	
			}
			
			
			
			
			
		if ($flag == 0)
			{
			my @input_data = @{$input_details{$position}};
			my $input_NIindex = $input_data[1];
			my $input_observed_prop_of_reads = sprintf ("%.8f", ($input_data[2]));
			
			print OUTFILE2 "$position\t$input_data[0]\t0\t$input_observed_prop_of_reads\t0\t$input_observed_prop_of_reads\tInf\t$input_data[5]\t$input_data[6]\t$input_data[7]\t$input_data[8]\t$input_data[9]\n";
			$input_only++;
			}
		}


	foreach (@output_positions)
		{
		chomp $_;
		my $position = $_;

		if (exists $input_details{$position}){}
		else {
			my @output_data = @{$output_details{$position}};
			my $output_NIindex = $output_data[1];
			my $output_observed_prop_of_reads = sprintf ("%.8f", ($output_data[2]));
			print OUTFILE3 "$position\t0\t$output_data[0]\t0\t$output_observed_prop_of_reads\t$output_observed_prop_of_reads\tNegative_Inf\t$output_data[5]\t$output_data[6]\t$output_data[7]\t$output_data[8]\t$output_data[9]\n";
			$output_only++;
			}
		}
#############################################################################################################################
#TRANSFORM & ANALYSE SHARED DATA
#Within an experiment The natural logarithm (base e) transformed proportion ratio approximates a normal distribution. Using the
#mean (shared mean) and standard deviation (shared sd) of this population, for each insertion the
#input/output proportion ratio (Proportion ratio) the Zscore is calculated as:
#Zscore = ((log(Proportion ratio)) - (shared mean)) / (shared sd)
#To provide some approximation of statistical significance. Zscores > standard deviations equivalent to a pvalue of
#0.001, 0.01, 0.05 are flagged as below. 
#If |Zscore| >= 3.291, Flag = "***" (~ p value = 0.001) 
#If 3.291 > |Zscore| >= 2.579, Flag = "**" (~ p value = 0.01)
#If 2.579 > |Zscore| >= 1.960, Flag = "*" (~ p value = 0.05)
#If |Zscore| < 1.960, Flag = "".
#############################################################################################################################

my @log_transformed_shared_proportion_ratios = log_array(@shared_proportion_ratios);
my ($shared_prop_ratio_mean, $shared_prop_ratio_stdev) = split '\t', stats(@log_transformed_shared_proportion_ratios);
my $zscore_gt1 = 0;
my $zscore_gt2 = 0;
my $zscore_gt3 = 0;
my $zscore_lteminus1 = 0;
my $zscore_lteminus2 = 0;
my $zscore_lteminus3 = 0;

foreach (@shared_positions) 
	{
	chomp $_; 
	my $dataline = $shared_position_data{$_};
	my @data = split '\t', $shared_position_data{$_};
	my $prop_ratio = $data[6];
	my $log_transformed_prop_ratio = log($prop_ratio);
	my $zscore = (($log_transformed_prop_ratio - $shared_prop_ratio_mean)/$shared_prop_ratio_stdev);
	
	my $zscore_print = sprintf ("%.3f", ($zscore));
	print OUTFILE "$dataline\t$zscore_print\t"; 
	
	my $flag = "";
	
	if ($zscore >= 3.291) {$zscore_gt3++;$flag ="***";}
	elsif ($zscore >= 2.579) {$zscore_gt2++;$flag ="**";}
	elsif ($zscore >= 1.960) {$zscore_gt1++;$flag ="*";}
	
	elsif ($zscore <= -3.291) {$zscore_lteminus3++;$flag ="***";}
	elsif ($zscore <= -2.579) {$zscore_lteminus2++;$flag ="**";}
	elsif ($zscore <= -1.960) {$zscore_lteminus1++;$flag ="*";}
	print OUTFILE "$flag\n";
	}

#############################################################################################################################
#SUMMARY AND CLEAN UP
#############################################################################################################################

unless (-d "IO.comparision.Tables"){system "mkdir IO.comparision.Tables";}
system "mv $name\.coverage\.$coverage\.PIMMS\.IO\.d$distance_to_collapse\.shared.position.table $name\.coverage\.$coverage\.PIMMS\.IO\.d$distance_to_collapse\.Input_only.position.table $name\.coverage\.$coverage\.PIMMS\.IO\.d$distance_to_collapse\.Output_only.position.table IO.comparision.Tables\/";


my $total = $input_only+$output_only+$shared_positions;
my $shared_pc = sprintf("%.2f", (100*($shared_positions / $total)));
my $input_only_pc = sprintf("%.2f", (100*($input_only / $total)));
my $output_only_pc = sprintf("%.2f", (100*($output_only / $total)));


#############################################################################################################################
#CREATE LOG FILE
#############################################################################################################################
open LOG, ">$name\.coverage\.$coverage\.PIMMS\.IO\.d$distance_to_collapse\.log";
$time = localtime;

print LOG "$usage\n";
my $commandline = $0;
print LOG "Command Used\n$commandline -i $input -o $output -d $distance_to_collapse -n $name\n\n";
print LOG "Time Started \= $time";

print LOG "\n======================================================================\nInput file\:\t$input\n";
print LOG "Output file\:\t$output\n";

print LOG "Total positions\:$total\n";
print LOG "Shared positions\:$shared_positions \($shared_pc\%\)\n";
print LOG "Of $shared_positions those included after collapse at $distance_to_collapse bp\:$collapsed_position_matched\n";

print LOG "Input only positions\:$input_only \($input_only_pc\%\)\n";
print LOG "Output only positions\:$output_only \($output_only_pc\%\)\n";
print LOG "======================================================================\n";
print LOG "Of shared positions\:\n";
print LOG "Mean of log transformed proportion ratio\:$shared_prop_ratio_mean\n";
print LOG "Standard Deviation of log transformed proportion ratio\:$shared_prop_ratio_stdev\n";
print LOG "Number of positions with Zscore \>\= 3.291\ \(p < 0.001\): $zscore_gt3\n";
print LOG "Number of positions with Zscore \>\= 2.579 \(p < 0.01\)\: $zscore_gt2\n";
print LOG "Number of positions with Zscore \>\= 1.960\ \(p < 0.05\): $zscore_gt1\n";

print LOG "Number of positions with Zscore \<\= \-3.291\ \(p < 0.001\): $zscore_lteminus3\n";
print LOG "Number of positions with Zscore \<\= \-2.579 \(p < 0.01\)\: $zscore_lteminus2\n";
print LOG "Number of positions with Zscore \<\= \-1.960\ \(p < 0.05\): $zscore_lteminus1\n";


print LOG "======================================================================\n\n";


#############################################################################################################################
#SUBROUTINES
#############################################################################################################################

sub log_array{
	my @holding = ();
        @holding = @_;
	my @return = ();
	
	foreach (@holding)	
		{
		chomp $_;
		my $transformed = log($_);
		push @return, $transformed;
		}
	return @return
	}

sub stats{
        my @holding = ();
        @holding = @_;
        my $count = 0;
        my $mean = 0;
        my $median = 0;
        my $stdev = 0;
        
        my $stat = Statistics::Descriptive::Full ->new();
        $stat->add_data(@holding);
        $count = $stat->count();
        $mean = $stat ->mean();
        $median = $stat->median(); 
        $stdev = $stat->standard_deviation();
                
        my $stat_return = "$mean\t$stdev";
        return $stat_return;
        @holding = ();
        }
}
